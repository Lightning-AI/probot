import { ProgressReport, SubProjConfig } from "../types";

export const generateProgressReport = (
  subprojects: SubProjConfig[],
  checksStatusLookup: Record<string, string>,
): ProgressReport => {
  const report: ProgressReport = {
    completed: [],
    expected: [],
    failed: [],
    missing: [],
    needAction: [],
    running: [],
    succeeded: [],
  };
  const lookup: Record<string, boolean> = {};
  subprojects.forEach((proj) => {
    proj.checks.forEach((check) => {
      /* eslint-disable security/detect-object-injection */
      if (!(check.id in lookup)) {
        lookup[check.id] = true;
        report.expected?.push(check.id);
        if (check.id in checksStatusLookup) {
          const status = checksStatusLookup[check.id];
          if (status === "success") {
            report.completed?.push(check.id);
            report.succeeded?.push(check.id);
          }
          if (status === "failure") {
            report.completed?.push(check.id);
            report.failed?.push(check.id);
          }
          if (status === "pending") {
            report.running?.push(check.id);
          }
        }
      }
      /* eslint-enable security/detect-object-injection */
    });
  });
  return report;
};

export const generateProgressSummary = (
  subprojects: SubProjConfig[],
  checksStatusLookup: Record<string, string>,
): string => {
  const report = generateProgressReport(subprojects, checksStatusLookup);
  const message = `Progress: ${report.completed?.length} completed, ${report.running?.length} pending`;
  return message;
};

export const statusToMark = (
  check: string,
  checksStatusLookup: Record<string, string>,
): string => {
  if (check in checksStatusLookup) {
    if (checksStatusLookup[check] == "success") {
      return "✅";
    }
    if (checksStatusLookup[check] == "failure") {
      return "❌";
    }
  } else {
    return "⌛";
  }
  return "❓";
};

/**
 * Generates a progress report for currently finished checks
 * which will be posted in the status check report.
 *
 * @param subprojects The subprojects that the PR matches.
 * @param checksStatusLookup The lookup table for checks status.
 */
export const generateProgressDetails = (
  subprojects: SubProjConfig[],
  checksStatusLookup: Record<string, string>,
): string => {
  let progress = "";

  // these are the required subprojects
  subprojects.forEach((subproject) => {
    progress += `Summary for sub-project ${subproject.id}\n`;
    // for padding
    const longestLength = Math.max(...(subproject.checks.map(check => check.id.length)));
    subproject.checks.forEach((check) => {
      const mark = statusToMark(check.id, checksStatusLookup);
      let status = (check.id in checksStatusLookup) ? checksStatusLookup[check.id] : 'no_status'
      status = status || 'undefined';
      progress += `${check.id.padEnd(longestLength, ' ')} | ${mark} | ${status.padEnd(12, ' ')}\n`;
    });
    progress += "\n\n";
  });
  progress += "\n";

  progress += "## Currently received checks\n";
  let longestLength = 1;
  for (const availableCheck in checksStatusLookup) {
    longestLength = Math.max(longestLength, availableCheck.length);
  }
  for (const availableCheck in checksStatusLookup) {
    const mark = statusToMark(availableCheck, checksStatusLookup);
    let status = (availableCheck in checksStatusLookup) ? checksStatusLookup[availableCheck] : 'no_status'
    status = status || 'undefined';
    progress += `${availableCheck.padEnd(longestLength, ' ')} | ${mark} | ${status.padEnd(12, ' ')}\n`;
  }
  progress += "\n";
  return progress;
};


// The following is adapted from
// https://github.com/pytorch/test-infra/blob/ed65888f0588f02b3e87ba773172d6f5d0bd69ea/torchci/lib/drciUtils.ts


import { IssueData } from "./types";
import fetchIssuesByLabel from "lib/fetchIssuesByLabel";
import { isPyTorchPyTorch } from "./bot/utils";
import { Context } from "probot";

export const NUM_MINUTES = 30;
export const REPO: string = "pytorch";
export const OWNER: string = "pytorch";
export const PR_COMMENT_START = "<!-- checkgroup-comment-start -->";

export function formPrComment(): string {
  return (
    "<!-- checkgroup-comment-start -->"
    + `\nHello! This is a test`
    + "\nThis comment was automatically generated by CheckGroup"
  )
}


export async function getPrComment(
  context: Context,
  owner: string,
  repo: string,
  prNum: number
): Promise<{id: number; body: string}> {
  const commentsRes = await context.octokit.rest.issues.listComments({
    owner: owner,
    repo: repo,
    issue_number: prNum,
  });
  for (const comment of commentsRes.data) {
    if (comment.body!.includes(PR_COMMENT_START)) {
      return {id: comment.id, body: comment.body!};
    }
  }
  return {id: 0, body: ""};
}


export async function upsertDrCiComment(owner: string, repo: string, prNum: number, context: Context, prUrl: string) {
  const existingDrciData = await getPrComment(context, owner, repo, prNum);
  context.log("Got existing ID: " + existingDrciData.id + " with body " + existingDrciData.body)
  const existingDrciID = existingDrciData.id;
  const existingDrciComment = existingDrciData.body;
  const drciComment = formPrComment();

  if (existingDrciComment === drciComment) {
    return;
  }

  if (existingDrciID === 0) {
    await context.octokit.issues.createComment({
      body: drciComment,
      owner: owner,
      repo: repo,
      issue_number: prNum,
    });
    context.log(
      `Commenting with "${drciComment}" for pull request ${prUrl}`
    );
  } else {
    context.log({
      body: drciComment,
      owner: owner,
      repo: repo,
      comment_id: existingDrciID,
    });
    await context.octokit.issues.updateComment({
      body: drciComment,
      owner: owner,
      repo: repo,
      comment_id: existingDrciID,
    });
    context.log(
      `Updated comment with "${drciComment}" for pull request ${prUrl}`
    );
  }
}